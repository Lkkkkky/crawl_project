# 输入 p，q 和 c
p = 104046835712664064779194734974271185635538927889880611929931939711001301561682270177931622974642789920918902563361293345434055764293612446888383912807143394009019803471816448923969637980671221111117965227402429634935481868701166522350570364727873283332371986860194245739423508566783663380619142431820861051179
q = 140171048074107988605773731671018901813928130582422889797732071529733091703843710859282267763783461738242958098610949120354497987945911021170842457552182880133642711307227072133812253341129830416158450499258216967879857581565380890788395068130033931180395926482431150295880926480086317733457392573931410220501
c = 5016479682696456978239277516052249270800778726777402564486649915670712153996746373831511013769860968666067122468818345402749866487575536085052197593911513644830697497572239225791032443070409121686821472371902829567952991277534554119492100314787545284741740612465082150686190546514697390880113052554161579838964365355306132657063248495054919830834628129624306710311889032215583852658336037060235793169438048254310292666195387626411702136892560884617668848518852169940442836899926197191896629465091771806095818559506006339381388218037366802376965851110558949802593344628710572652306200726789220716628113660017218640393
# 计算 n 和 φ(n)
n = p * q
phi_n = (p - 1) * (q - 1)

# 选择 e
e = 65537

# 计算 d
d = pow(e, -1, phi_n)

# 解密 c
m = pow(c, d, n)

# 输出明文
print("明文 m:", m)
# 假设m是从之前的代码中得到的解密后的明文
# m = ... (这里应该是你之前解密得到的明文数字)
# 将明文转换为16进制字符串
hex_string = hex(m)[2:].upper()
# [2:]用于去掉'0x'前缀，upper()将字母转换为大写
# 如果明文实际上是由ASCII字符组成，并且我们知道它没有包含非打印字符，
# 我们可以尝试将其从16进制转换回字符串。这通常不是一个安全的操作，除非你确定明文是文本。
# 为了从16进制转换回字符串，我们需要确保16进制字符串的长度是偶数，
# 如果不是，我们需要在前面添加一个零。
if len(hex_string) % 2 != 0:
    hex_string = '0' + hex_string

# 将16进制字符串转换为字节串，然后解码为字符串
try:
    decoded_string = bytes.fromhex(hex_string).decode('ascii')
    print("16进制表示的明文:", hex_string)
    print("转换后的字符串:", decoded_string)
except UnicodeDecodeError:
    print("明文可能不是由ASCII字符组成，或者包含了非打印字符。")